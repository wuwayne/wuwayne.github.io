---

layout: post

title:  "算法复杂度分析"

date:   2012-1-21 13:35:42 +0800

categories:  CS 算法

tags:   算法

---

### 什么是算法复杂度分析

就是分析特定算法在运行时所耗费的时间和存储空间的数量。

### 为什么要分析

为了衡量算法的好坏。就算一个算法能够正确地解决问题，但需要在计算机上运行100年或者需要占用 100TB 的内存，那也是没有意义的。

### 如何分析

通常2方面：

1. 时间复杂度
2. 空间复杂度

现今一般只考虑时间复杂度，因为存储空间的大小在现代计算机中已经越来越不再是一个问题。

### 时间复杂度


虽然讨论的是算法耗费的“时间”，但并不是真的去测量程序在计算机中的实际运行时间，因为实际运行时间依赖于特定机器平台（CPU、内存、操作系统、编程语言等）。

实际为估计出为解决问题需要执行的操作（或语句、 指令等类似概念）的数目，或称算法的“步数”。步数越多执行时间就越长，且不依赖于平台，更容易分析和比较。

### 大O表示法

根据函数的增长率特性来刻画函数，可以用来描述算法的复杂度。

### 算法分析的大局观

1. 忽略掉那些依赖于机器的常量。

2. 关注运行时间的增长趋势。

比如：T(n) = 73n3 + 29n3 + 8888 的趋势就相当于 T(n) = O(n3)。事实上，分析算法复杂度时，我们只分析其增长的数量级，而不是分析其精确的步数公式。

- 如果T(n)是若干项之和，则只需保留最高次项，省略所有低次项；

- 如果T(n)是若干项之积，则可省略任何常数因子（即与 n 无关的因子）

### 举例分析

	def f(n):
	    x = 0
	    for i in range(n): 
	        for j in range(n):
	            for k in range(n): 
	                x = x + 1
	    for i in range(n): 
	        for j in range(n):
	            for k in range(n): 
	                x = x + 1
	    for i in range(n): 
	        x = x + 1

易知此算法的步数为 2n3+n+1。根据第一条规则，可只保留2n3；再根据第二条规则，可只保留 n3。所以，此算法的复杂度为 O(n3)。

一般步骤：
1. 确定决定算法运行时间的组成步骤。

2. 找到执行该步骤的代码，标记为 1。

3. 查看标记为1的代码的下一行代码。如果下一行代码是一个循环，则将 标记 1 修改为 1 倍于循环的次数 1 * n。如果包含多个嵌套的循环，则将继续计算倍数，例如 1 * n * m。

4. 找到标记到的最大的值，就是运行时间的最大值，即算法复杂度描述的上界。

简便方法：先找到那些嵌套层数最多、并且每一层循环的循环次数都与问题规模 n 有关的循环。

### 各种算法复杂度比较

![](https://ws1.sinaimg.cn/large/692c25ffgy1fr7bhdnnpfj20cn07wt92.jpg)

----
以上！
